//
// Created by Lenovo on 2023/4/13.
//

#ifndef DATASTRUCTURE_MEITUANTEST_H
#define DATASTRUCTURE_MEITUANTEST_H

#include <vector>
#include <unordered_map>
#include <iostream>
#include <string>
#include <queue>
#include <stack>
#include <algorithm>

using namespace std;

class MeiTuanTest
{
public:
    MeiTuanTest();
    ~MeiTuanTest();

    //题目描述：
    //有一棵n个节点的树，有一条边被选定。小美想知道对于所有经过这条选定边的所有树上简单路径，最长的那条有多长

    //输入描述：
    //第一行一个整数n，表示树的节点个数
    //第二行n-1个整数，第i个整数pi表示节点i+1和pi之间有一条边相连
    //第三行两个整数x, y，表示这条选定的边。保证这条边一定是树上的一条边
    //对于全部数据，2<=n<=1e5，1<=pi<=n, 1<=x, y<=n, x \neq y, 保证输入数据正确描述一棵树，并且(x, y)是树上的一条边

    //输出描述：
    //输出一行，一个整数，表示所有经过选定边的树上简单路径中，最长的那条的长度

    //样例输入：
    //7
    //1 2 3 4 5 3
    //3 7
    //样例输出：
    //4
    int dfs_Q1(vector<pair<int, int>>& link, int root, int length);
    int question1();

    //题目描述：
    //小团班级的座位排成了 n 行（行从 1 到 n 编号），共有 m 个大列（大列从 1 到 m 编号），每个大列中有 a 个小列（小列从 1 到 a 编号），大列与大列之间有一个过道。
    //小团的班级每周会换一次座位，首先所有同学都换到后一行，最后一行的同学换到第一行，然后所有同学都移动到自己右边的那个大列的相同小列上，在最右大列的同学移动到最左大列。
    //换句话说，对于坐在第 i<n 行的同学，新位置在第 i+1 行，如果 i=n，那么新位置在第一行；对于坐在第 j<m 大列的同学，新位置在第 j+1 大列，如果 j=m，那么新位置在第一大列；
    //对于坐在第 k 小列的同学，新位置仍然在第 k 小列。
    //小团的学校最近换了一批学生桌椅。这批学生桌椅的优点在于可以调节桌子的高度，一些同学调整了桌子高度，但是另一些没有。
    //这样换座就变得麻烦了起来，如果一位调整了桌子高度的同学换到了未调整桌子高度同学的位置，他就会调整新位置的桌子到他想要的高度，
    //而一位没有调整桌子高度的同学换到了调整过桌子高度同学的位置，他也会调整新位置的桌子高度，使其恢复原高度。
    //现在小团的班级要进行换座位了，给出换座位前班级所有桌子的情况，小团想知道，换一次位置后，有多少同学需要重新调整桌子高度。
    //输入描述：
    //输入第一行包含三个数 n, m, a，意义如题目所示。
    //接下来 n 行，每行 m 个长度为 a 的 01 字符串，表示目前小团班上的桌子情况。其中 0 表示这个位置未调节桌子高度，1表示已调节桌子高度。
    //对于全部数据，1 ≤ n, m ≤ 200, n × m ≥ 2, 1 ≤ a ≤ 5。
    //输出描述：
    //输出一行一个整数，表示换作为后有多少同学需要重新调整桌子高度
    //样例输入：
    //3 3 2
    //01 10 00
    //10 00 11
    //01 00 00
    //样例输出：
    //8
    //样例输入：
    //3 3 3
    //011 100 000
    //100 000 110
    //010 000 000
    //样例输出：
    //10
    int question2();//排座位

    //题目描述：
    //小美不干外卖配送了，转行开了一家水果店。
    //一天她接到了一个大单，客户订购了 n 个水果，并且要求打包成多个果篮，一个果篮最多装 m 个水果。
    //为了包装方便，水果按从 1 到 n 编号，同一个果篮里装的水果编号必须是连续的。
    //果篮的成本与容积成线性关系。为了估计容积，小美简单地用样本中点估计了一下。
    //具体来说，假设一个果篮中装的最大的水果体积是 u，最小的是 v，
    //那么这个果篮的成本就是 k × floor((u+v)/2) + s，其中 k 是果篮中装入水果的个数，s 是一个常数，floor(x) 是下取整函数，比如 floor(3.8)=3, floor(2)=2。
    //客户并没有规定果篮的数量，但是希望果篮的成本越小越好，毕竟买水果就很贵了。请求出小美打包这 n 个水果所用的最小花费。
    //输入描述：
    //第一行三个正整数 n, m, s。意义如题面所示。n表示客户订购了n个水果，m表示一个果篮最多装m个水果，s表示一个常数。
    //第二行 n 个正整数 a1, a2, …, an，表示每个水果的体积。
    //对于全部数据，1 ≤ n ≤ 104, 1 ≤ m ≤ 103, m ≤ n, 1 ≤ ai, s ≤ 104。
    //样例输入：
    //6 4 3
    //1 4 5 1 4 1
    //样例输出：
    //21
    //提示：
    //样例说明，前三个水果装成一个果篮，后三个水果装成一个果篮
    int question3();//水果打包，动态规划

    int question4(int back_size, vector<int>& nums, vector<int>& values);//动态规划，背包问题，一维dp数组方法
};


#endif //DATASTRUCTURE_MEITUANTEST_H
